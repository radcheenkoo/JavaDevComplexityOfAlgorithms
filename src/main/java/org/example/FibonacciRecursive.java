package org.example;


/**
 *
 * Просторова складність:
 *
 * Просторова складність алгоритму становить  O(n).
 * Даний рекурсивний алгоритм використовує стек викликів
 * для збереження проміжних результатів обчислення,
 * оскільки залежить від глибини рекурсії, що лінійно зростає
 * зі збільшенням n, також глибина рекурсії зростає лінійно
 * з розміром вхідних даних.
 *
 *
 * Часова складність:
 *
 * На кожному рівні глибини рекурсії виконується
 * константна кількість операцій. Оскільки глибина рекурсії
 * може бути порядку n, а кожна рекурсивна гілка обчислюється окремо,
 * часова складність алгоритму є експоненційною, тобто O(2^n).
 * Кожен рекурсивний виклик подібно до двійкового дерева,
 * і загальна кількість викликів дорівнює 2^n - 1.
 *
 *
 * Короткий опис до алгоритму:
 *
 * Рекурсивний підхід до обчислення чисел Фібоначчі
 * має високу складність обчислення,
 * особливо для великих значень n. Повторні обчислення
 * підзадач при великих значеннях n можуть призвести до
 * довгих часів виконання і можливого переповнення
 * стеку викликів (Stack Overflow) при глибоких рекурсивних викликах
 * або великих значеннях n. У випадку обчислення чисел
 * Фібоначчі рекомендовано використовувати інші методи,
 * такі як динамічне програмування або ітеративний підхід,
 * для забезпечення більшої ефективності та уникнення недоліків,
 * пов'язаних із рекурсією.
 *
 * */

public class FibonacciRecursive {
    public int calculateFibonacci(int n){
        if (n <= 1){
            return n;
        }
        return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);
    }
}
